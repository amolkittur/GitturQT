{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Goals and Overview Project Purpose GitturQT is all about making the developer's life easier\u2014because, let\u2019s face it, developers have enough to deal with already. By making Git the main action center for all code development activities, we're giving developers a single source of truth. The goal here is pretty simple: take an idea, put it into a Product Requirements Document (PRD), and then break it down, phase by phase, until it\u2019s something even the most sleep-deprived dev can handle on a daily basis (Red Bull ad). By the end of each day, the developer should add value to themselves; by the end of each week, add value to their colleagues; and by the end of each month, add value to the world. GitHub is the home for all these tasks, keeping everything neat, organized, and hopefully reducing the \"Wait, what was I supposed to do again?\" moments. So yes, we're taking chaos and trying to turn it into something at least resembling a streamlined process. Methodology In today's fast-paced development environment, GitturQT aims to enhance productivity by integrating AI into the typical developer workflow while keeping developers in control at every stage. This Human-in-the-Loop (HIL) approach means that developers can harness the power of AI for routine and complex tasks, but always with the ability to intervene, adjust, and guide the process to align with conscious, value-driven development. Developers are supposed to review consciously at every step along this path; else the product is going to be useless. Below, we outline the lifecycle phases and how HIL AI involvement can make each step more efficient and enjoyable. Lifecycle Phases and HIL AI Involvement PRD Creation (Once a Month) AI Assistance : Generating the initial Product Requirements Document by providing template suggestions based on previous projects and industry standards. Essential Ingredients for a Good PRD : PRD Template : A starting point for your PRD that includes all the necessary sections. Meeting Transcription : The AI transcribes brainstorming sessions, so no idea is left behind. Who has time for typing up notes, anyway? Custom Prompt : The AI uses a personalized prompt that understands your team's unique quirks and preferences (including a love for puns, if that\u2019s your style). Developer Control : Modify AI-generated suggestions for relevance and accuracy. Phase Document (Once a Week) AI Assistance : Breaking the PRD into specific phases, recommending timelines and dependencies. Requirements for a Phase Document : PRD Doc : AI takes the existing PRD and extracts the relevant parts. Phase Meeting Transcript : AI captures all the fascinating conversations about timelines and dependencies, complete with those \"aha!\" moments. Custom Prompt : The AI provides tailored prompts to ensure the phase descriptions aren\u2019t just informative but also entertaining (like comparing phase timelines to running a marathon\u2014slow and steady wins the race). Developer Control : Adjust phase definitions, timelines, and dependencies to align with project priorities. Issue Document (Daily) AI Assistance : Providing granular daily tasks derived from the weekly phases, helping developers manage daily activities. Components of an Effective Issue Document : Phase Doc : Using the phase breakdown as a guide. Daily Meeting Transcript : AI transcribes daily stand-ups, capturing all those \"we should do this today\" moments. Custom Prompt : A special prompt to help break down each task into something manageable, perhaps sprinkled with motivational quotes to keep spirits high (\"One bug at a time, my friends\"). Developer Control : Refine, add, or remove tasks as needed, allowing for adaptability based on evolving project needs. Branch Creation & Commit Messages AI Assistance : Creating branches and generating commit message templates based on task descriptions. Developer Control : Retain control over the final commit message, ensuring it aligns with team standards. Pull Request (PR) Creation & Review AI Assistance : Suggesting PR descriptions and conducting preliminary reviews by analyzing code quality and potential issues. Developer Control : Perform final reviews, make necessary adjustments, and approve the PR. Testing & Closing Phases AI Assistance : Automating test case generation and providing insights into test coverage. Developer Control : Remain in control of test execution and approve phase closure, maintaining accountability. This HIL AI-based methodology ensures that developers have granular control at every step of the software development process while leveraging AI to automate routine tasks, provide recommendations, and maintain focus on conscious, value-driven development. Development Strategy Middle-Out Approach Let's talk about the middle-out strategy. Imagine you're building a Ferrari\u2014not starting with the flashy paint job (the PRD) or the fancy leather seats (the UI). Nope, we\u2019re diving right into the roaring engine that makes the Ferrari a Ferrari. We're talking about the twin-turbo V8\u2014the part that makes people turn their heads, the part that defines the power and experience. The idea is to focus on the core components that make everything work\u2014simplifying the issue creation process and developing essential AI agents like the audio transcription agent. We\u2019re not here to admire the cup holders or the infotainment system; we\u2019re getting straight to what really matters\u2014the engine that drives everything. Because, at the end of the day, no one's impressed by a Ferrari that looks pretty but doesn\u2019t run. By starting at the midpoint, we can build outward to connect both ends of the development process. First, we nail down the critical features that will form the backbone of the project. Then, we can circle back to polish the PRD side and add a beautiful interface that makes everything shine. It\u2019s a bit unconventional\u2014sure\u2014but it\u2019s all about developing the features that make a difference. Let's be honest, who needs another meeting template when what we really need is something that works right now! In Our Case In our case, the middle-out approach means starting with the most impactful features that can make developers' lives easier from the get-go. The core features to begin with are: Audio Transcription Agent : Converts conversations, meetings, and brainstorming sessions into written records without any manual effort. Imagine not needing to scramble for notes during a meeting\u2014just let the AI transcribe everything, ensuring that no idea gets lost. Why : The Audio Transcription Agent is ranked first because it serves as the foundation for capturing all valuable insights, ideas, and decisions made during discussions. Without clear, accurate notes, the rest of the process can become chaotic. This agent eliminates the burden of note-taking and ensures that no key information is lost, creating a solid basis for everything that follows. Phase Document Generator : Breaking down the PRD into phases is essential for organizing the workflow. This tool helps structure broad ideas into manageable sections, paving the way for easier implementation. Issue Generation Agent : Once we have the phases, it's time to break them into daily tasks. This agent ensures that developers know exactly what to focus on each day to keep the project moving forward. These three components form the backbone of our middle-out development strategy. By focusing on these core agents first, we ensure that developers have a streamlined and efficient workflow. Once these core features are in place, we can expand to enhance the PRD creation, refine the UI, and add other features that will make GitturQT an even more powerful tool. Implementation and Deployment The implementation and deployment of GitturQT involve careful planning to ensure seamless integration, robust functionality, and consistent availability. This section provides a comprehensive overview of the architecture, tools, and processes for setting up and deploying the GitturQT project. Architecture Overview Model-View-Controller (MVC) : GitturQT follows an MVC architecture, ensuring a clear separation of concerns: Model : Handles all data-related logic. It represents the core business data, including PRDs, phases, issues, and user settings. It interacts with the database to fetch and save data as required. View : The presentation layer, which can be either a PyQT desktop interface or a web interface (final decision pending). It handles user interaction, providing a graphical representation of the data and capturing user inputs. Controller : Acts as an intermediary between the Model and View layers. It processes user inputs, communicates with the Model to retrieve data, and then updates the View accordingly. Technology Stack Backend : Python FastAPI for building the backend REST APIs. FastAPI is chosen for its asynchronous capabilities, making it highly performant for handling multiple requests, and its intuitive nature makes API development efficient. Frontend : PyQT : Provides a desktop GUI experience, ideal for developers who prefer a local, non-browser-based environment. Web Interface : A web-based UI using HTML, CSS, and JavaScript, accessible via any browser. This option is more versatile, allowing for remote access and collaboration. Database : A SQL database (e.g., PostgreSQL or SQLite) for persistent storage. The Model interacts with the database to store data related to PRDs, phases, issues, and user settings. Server : Deployed on a macOS server with a static IP address, making it accessible to all team members from various locations. Additional Tools : Hakuna Matata (purpose to be defined). Implementation Details Setting Up the Environment : Server Configuration : Configure the macOS server with all required software installations, such as Python, PostgreSQL, and other dependencies. Enable secure SSH access for remote management. Python Virtual Environment : Use venv to create a virtual environment for isolating project dependencies, ensuring no conflicts between different versions of libraries. Git Integration : Clone the project repository onto the server using Git. Ensure all team members have appropriate permissions for branch creation and pushing commits. Backend Development : API Endpoints : Use FastAPI to create RESTful endpoints for CRUD operations on PRDs, phases, and issues. Document each endpoint clearly for ease of use by the frontend. Authentication : Implement OAuth2 for user authentication to ensure that only authorized users can access and modify project data. Database Schema : Define the database schema for entities like PRD, phases, issues, and users. Use SQLAlchemy to interact with the database. Frontend Development : PyQT Interface : If a desktop application is preferred, develop the GUI using PyQT. Allow users to create, view, and update PRDs, phases, and issues in a user-friendly way. Web Interface : For a web interface, use a JavaScript framework like Vue.js or React to build a dynamic frontend. This UI should interact with the FastAPI backend to fetch and display data in real-time. Deployment Plan Deployment Steps : Set Up Static IP : Assign a static IP to the macOS server to make it accessible from anywhere. Configure the DNS if needed for easier access. Reverse Proxy : Set up a reverse proxy using Nginx or Apache to direct incoming requests to the appropriate FastAPI port, providing better security and load management. SSL Configuration : Secure communication using an SSL certificate to encrypt all data between the client and the server, ensuring data privacy and integrity. Database Migration : Use Alembic (a tool for managing SQLAlchemy database migrations) to handle database schema changes as the project evolves. CI/CD Pipeline : Set up Continuous Integration/Continuous Deployment pipelines using GitHub Actions. Every push to the main branch should trigger automated tests and, upon passing, automatically deploy the updated code to the server. Maintenance and Monitoring Logging and Monitoring : Implement logging using Python\u2019s logging library to track server activity and errors. Use monitoring tools like Prometheus or Grafana to monitor server health, response times, and resource utilization. Backups : Schedule regular backups of the database to avoid data loss. Store these backups off-site to ensure redundancy. Scalability : Design the architecture to be scalable. In the event of increased traffic, consider scaling horizontally by adding more servers or vertically by upgrading the current server\u2019s hardware. API Cost Monitoring : Implement monitoring to keep track of API usage and associated costs. Decision Point: Desktop vs Web Interface PyQT Desktop GUI : Offers a rich desktop experience with advanced GUI elements. Suitable for developers who prefer working locally. Web Interface : More accessible, ideal for remote teams or situations where users may need to access the tool from multiple devices. Recommendation : Consider a hybrid approach where a core set of functionalities is available in both formats, allowing users to choose whichever suits their needs best.","title":"Goals and Overview"},{"location":"#goals-and-overview","text":"","title":"Goals and Overview"},{"location":"#project-purpose","text":"GitturQT is all about making the developer's life easier\u2014because, let\u2019s face it, developers have enough to deal with already. By making Git the main action center for all code development activities, we're giving developers a single source of truth. The goal here is pretty simple: take an idea, put it into a Product Requirements Document (PRD), and then break it down, phase by phase, until it\u2019s something even the most sleep-deprived dev can handle on a daily basis (Red Bull ad). By the end of each day, the developer should add value to themselves; by the end of each week, add value to their colleagues; and by the end of each month, add value to the world. GitHub is the home for all these tasks, keeping everything neat, organized, and hopefully reducing the \"Wait, what was I supposed to do again?\" moments. So yes, we're taking chaos and trying to turn it into something at least resembling a streamlined process.","title":"Project Purpose"},{"location":"#methodology","text":"In today's fast-paced development environment, GitturQT aims to enhance productivity by integrating AI into the typical developer workflow while keeping developers in control at every stage. This Human-in-the-Loop (HIL) approach means that developers can harness the power of AI for routine and complex tasks, but always with the ability to intervene, adjust, and guide the process to align with conscious, value-driven development. Developers are supposed to review consciously at every step along this path; else the product is going to be useless. Below, we outline the lifecycle phases and how HIL AI involvement can make each step more efficient and enjoyable.","title":"Methodology"},{"location":"#lifecycle-phases-and-hil-ai-involvement","text":"","title":"Lifecycle Phases and HIL AI Involvement"},{"location":"#prd-creation-once-a-month","text":"AI Assistance : Generating the initial Product Requirements Document by providing template suggestions based on previous projects and industry standards. Essential Ingredients for a Good PRD : PRD Template : A starting point for your PRD that includes all the necessary sections. Meeting Transcription : The AI transcribes brainstorming sessions, so no idea is left behind. Who has time for typing up notes, anyway? Custom Prompt : The AI uses a personalized prompt that understands your team's unique quirks and preferences (including a love for puns, if that\u2019s your style). Developer Control : Modify AI-generated suggestions for relevance and accuracy.","title":"PRD Creation (Once a Month)"},{"location":"#phase-document-once-a-week","text":"AI Assistance : Breaking the PRD into specific phases, recommending timelines and dependencies. Requirements for a Phase Document : PRD Doc : AI takes the existing PRD and extracts the relevant parts. Phase Meeting Transcript : AI captures all the fascinating conversations about timelines and dependencies, complete with those \"aha!\" moments. Custom Prompt : The AI provides tailored prompts to ensure the phase descriptions aren\u2019t just informative but also entertaining (like comparing phase timelines to running a marathon\u2014slow and steady wins the race). Developer Control : Adjust phase definitions, timelines, and dependencies to align with project priorities.","title":"Phase Document (Once a Week)"},{"location":"#issue-document-daily","text":"AI Assistance : Providing granular daily tasks derived from the weekly phases, helping developers manage daily activities. Components of an Effective Issue Document : Phase Doc : Using the phase breakdown as a guide. Daily Meeting Transcript : AI transcribes daily stand-ups, capturing all those \"we should do this today\" moments. Custom Prompt : A special prompt to help break down each task into something manageable, perhaps sprinkled with motivational quotes to keep spirits high (\"One bug at a time, my friends\"). Developer Control : Refine, add, or remove tasks as needed, allowing for adaptability based on evolving project needs.","title":"Issue Document (Daily)"},{"location":"#branch-creation-commit-messages","text":"AI Assistance : Creating branches and generating commit message templates based on task descriptions. Developer Control : Retain control over the final commit message, ensuring it aligns with team standards.","title":"Branch Creation &amp; Commit Messages"},{"location":"#pull-request-pr-creation-review","text":"AI Assistance : Suggesting PR descriptions and conducting preliminary reviews by analyzing code quality and potential issues. Developer Control : Perform final reviews, make necessary adjustments, and approve the PR.","title":"Pull Request (PR) Creation &amp; Review"},{"location":"#testing-closing-phases","text":"AI Assistance : Automating test case generation and providing insights into test coverage. Developer Control : Remain in control of test execution and approve phase closure, maintaining accountability. This HIL AI-based methodology ensures that developers have granular control at every step of the software development process while leveraging AI to automate routine tasks, provide recommendations, and maintain focus on conscious, value-driven development.","title":"Testing &amp; Closing Phases"},{"location":"#development-strategy","text":"","title":"Development Strategy"},{"location":"#middle-out-approach","text":"Let's talk about the middle-out strategy. Imagine you're building a Ferrari\u2014not starting with the flashy paint job (the PRD) or the fancy leather seats (the UI). Nope, we\u2019re diving right into the roaring engine that makes the Ferrari a Ferrari. We're talking about the twin-turbo V8\u2014the part that makes people turn their heads, the part that defines the power and experience. The idea is to focus on the core components that make everything work\u2014simplifying the issue creation process and developing essential AI agents like the audio transcription agent. We\u2019re not here to admire the cup holders or the infotainment system; we\u2019re getting straight to what really matters\u2014the engine that drives everything. Because, at the end of the day, no one's impressed by a Ferrari that looks pretty but doesn\u2019t run. By starting at the midpoint, we can build outward to connect both ends of the development process. First, we nail down the critical features that will form the backbone of the project. Then, we can circle back to polish the PRD side and add a beautiful interface that makes everything shine. It\u2019s a bit unconventional\u2014sure\u2014but it\u2019s all about developing the features that make a difference. Let's be honest, who needs another meeting template when what we really need is something that works right now!","title":"Middle-Out Approach"},{"location":"#in-our-case","text":"In our case, the middle-out approach means starting with the most impactful features that can make developers' lives easier from the get-go. The core features to begin with are: Audio Transcription Agent : Converts conversations, meetings, and brainstorming sessions into written records without any manual effort. Imagine not needing to scramble for notes during a meeting\u2014just let the AI transcribe everything, ensuring that no idea gets lost. Why : The Audio Transcription Agent is ranked first because it serves as the foundation for capturing all valuable insights, ideas, and decisions made during discussions. Without clear, accurate notes, the rest of the process can become chaotic. This agent eliminates the burden of note-taking and ensures that no key information is lost, creating a solid basis for everything that follows. Phase Document Generator : Breaking down the PRD into phases is essential for organizing the workflow. This tool helps structure broad ideas into manageable sections, paving the way for easier implementation. Issue Generation Agent : Once we have the phases, it's time to break them into daily tasks. This agent ensures that developers know exactly what to focus on each day to keep the project moving forward. These three components form the backbone of our middle-out development strategy. By focusing on these core agents first, we ensure that developers have a streamlined and efficient workflow. Once these core features are in place, we can expand to enhance the PRD creation, refine the UI, and add other features that will make GitturQT an even more powerful tool.","title":"In Our Case"},{"location":"#implementation-and-deployment","text":"The implementation and deployment of GitturQT involve careful planning to ensure seamless integration, robust functionality, and consistent availability. This section provides a comprehensive overview of the architecture, tools, and processes for setting up and deploying the GitturQT project.","title":"Implementation and Deployment"},{"location":"#architecture-overview","text":"Model-View-Controller (MVC) : GitturQT follows an MVC architecture, ensuring a clear separation of concerns: Model : Handles all data-related logic. It represents the core business data, including PRDs, phases, issues, and user settings. It interacts with the database to fetch and save data as required. View : The presentation layer, which can be either a PyQT desktop interface or a web interface (final decision pending). It handles user interaction, providing a graphical representation of the data and capturing user inputs. Controller : Acts as an intermediary between the Model and View layers. It processes user inputs, communicates with the Model to retrieve data, and then updates the View accordingly.","title":"Architecture Overview"},{"location":"#technology-stack","text":"Backend : Python FastAPI for building the backend REST APIs. FastAPI is chosen for its asynchronous capabilities, making it highly performant for handling multiple requests, and its intuitive nature makes API development efficient. Frontend : PyQT : Provides a desktop GUI experience, ideal for developers who prefer a local, non-browser-based environment. Web Interface : A web-based UI using HTML, CSS, and JavaScript, accessible via any browser. This option is more versatile, allowing for remote access and collaboration. Database : A SQL database (e.g., PostgreSQL or SQLite) for persistent storage. The Model interacts with the database to store data related to PRDs, phases, issues, and user settings. Server : Deployed on a macOS server with a static IP address, making it accessible to all team members from various locations. Additional Tools : Hakuna Matata (purpose to be defined).","title":"Technology Stack"},{"location":"#implementation-details","text":"Setting Up the Environment : Server Configuration : Configure the macOS server with all required software installations, such as Python, PostgreSQL, and other dependencies. Enable secure SSH access for remote management. Python Virtual Environment : Use venv to create a virtual environment for isolating project dependencies, ensuring no conflicts between different versions of libraries. Git Integration : Clone the project repository onto the server using Git. Ensure all team members have appropriate permissions for branch creation and pushing commits. Backend Development : API Endpoints : Use FastAPI to create RESTful endpoints for CRUD operations on PRDs, phases, and issues. Document each endpoint clearly for ease of use by the frontend. Authentication : Implement OAuth2 for user authentication to ensure that only authorized users can access and modify project data. Database Schema : Define the database schema for entities like PRD, phases, issues, and users. Use SQLAlchemy to interact with the database. Frontend Development : PyQT Interface : If a desktop application is preferred, develop the GUI using PyQT. Allow users to create, view, and update PRDs, phases, and issues in a user-friendly way. Web Interface : For a web interface, use a JavaScript framework like Vue.js or React to build a dynamic frontend. This UI should interact with the FastAPI backend to fetch and display data in real-time.","title":"Implementation Details"},{"location":"#deployment-plan","text":"Deployment Steps : Set Up Static IP : Assign a static IP to the macOS server to make it accessible from anywhere. Configure the DNS if needed for easier access. Reverse Proxy : Set up a reverse proxy using Nginx or Apache to direct incoming requests to the appropriate FastAPI port, providing better security and load management. SSL Configuration : Secure communication using an SSL certificate to encrypt all data between the client and the server, ensuring data privacy and integrity. Database Migration : Use Alembic (a tool for managing SQLAlchemy database migrations) to handle database schema changes as the project evolves. CI/CD Pipeline : Set up Continuous Integration/Continuous Deployment pipelines using GitHub Actions. Every push to the main branch should trigger automated tests and, upon passing, automatically deploy the updated code to the server.","title":"Deployment Plan"},{"location":"#maintenance-and-monitoring","text":"Logging and Monitoring : Implement logging using Python\u2019s logging library to track server activity and errors. Use monitoring tools like Prometheus or Grafana to monitor server health, response times, and resource utilization. Backups : Schedule regular backups of the database to avoid data loss. Store these backups off-site to ensure redundancy. Scalability : Design the architecture to be scalable. In the event of increased traffic, consider scaling horizontally by adding more servers or vertically by upgrading the current server\u2019s hardware. API Cost Monitoring : Implement monitoring to keep track of API usage and associated costs.","title":"Maintenance and Monitoring"},{"location":"#decision-point-desktop-vs-web-interface","text":"PyQT Desktop GUI : Offers a rich desktop experience with advanced GUI elements. Suitable for developers who prefer working locally. Web Interface : More accessible, ideal for remote teams or situations where users may need to access the tool from multiple devices. Recommendation : Consider a hybrid approach where a core set of functionalities is available in both formats, allowing users to choose whichever suits their needs best.","title":"Decision Point: Desktop vs Web Interface"},{"location":"phases/phase1/","text":"5.1 Idea Input and PRD Generation(Phase 1) Start Date : 07Oct24 End Date : 11Oct24 5.1.3 Start Date : 09Oct24 Daily Pramana Vachana : Creating a detailed github issues from the Phase document taking inputs from the user such as meeting transcripts, documents, and custom prompts. 5.1.4 Start Date : 10Oct24 Daily Pramana Vachana : I will master the patterns for the following documents 1. Objective Oriented Meeting Starter 1.1 PRD Meeting starter (Beginning of the project) 1.1.1 Tech stack 1.1.2 Real world translation : The most critical features required for the world that month 1.1.3 Hosting details 1.2 Phase Meeting Starter(Every monday) 1.2.1 Library/Framework documentation 1.2.2 Real world translation : The most critical features required for the team that week 1.2.3 Deployment details 1.3 Daily Meeting Starter(Everyday at 11-12:30 pm) 1.3.1 Hathyar : Youtube video/twitter/github transcripts : fabric github repo, videos related to ai agents, twitter posts related to ai agents and fabric. 1.3.2 Chinthan : Real world translation : Migration of ai agents from local to hakuna matata 1.3.3 Prasar : Deployment details : I feel lot more confident next week starting phase 2 work. 1.4 Phase meeting middler(Every wednesday : 16Oct24) 1.4.1 1.5 Phase meeting ender(Every friday: 10Oct24) 1.5.1 User Documentation : Update the Readme.md with the new changes before the deployment. 1.5.2 Github release : Create a new release with the new changes and update the changelog. 1.5.3 Backend Cleaning : Close the issue and delete the branch. 1.5.4 Group Testing : Deploy on Friday and happy weekend. Better the deployment happier the weekend. 1.6 PRD meeting middler(15Oct24) 1.6.1 1.7 PRD meeting ender(31Oct24) 1.7.1 PRD Meeting Transcripts: PRD Documents Phase List Issue List Github Issues","title":"Phase1"},{"location":"phases/phase1/#51-idea-input-and-prd-generationphase-1","text":"","title":"5.1 Idea Input and PRD Generation(Phase 1)"},{"location":"phases/phase1/#start-date-07oct24","text":"","title":"Start Date : 07Oct24"},{"location":"phases/phase1/#end-date-11oct24","text":"","title":"End Date : 11Oct24"},{"location":"phases/phase1/#513","text":"","title":"5.1.3"},{"location":"phases/phase1/#start-date-09oct24","text":"","title":"Start Date : 09Oct24"},{"location":"phases/phase1/#daily-pramana-vachana-creating-a-detailed-github-issues-from-the-phase-document-taking-inputs-from-the-user-such-as-meeting-transcripts-documents-and-custom-prompts","text":"","title":"Daily Pramana Vachana : Creating a detailed github issues from the Phase document taking inputs from the user such as meeting transcripts, documents, and custom prompts."},{"location":"phases/phase1/#514","text":"","title":"5.1.4"},{"location":"phases/phase1/#start-date-10oct24","text":"","title":"Start Date : 10Oct24"},{"location":"phases/phase1/#daily-pramana-vachana-i-will-master-the-patterns-for-the-following-documents","text":"1. Objective Oriented Meeting Starter 1.1 PRD Meeting starter (Beginning of the project) 1.1.1 Tech stack 1.1.2 Real world translation : The most critical features required for the world that month 1.1.3 Hosting details 1.2 Phase Meeting Starter(Every monday) 1.2.1 Library/Framework documentation 1.2.2 Real world translation : The most critical features required for the team that week 1.2.3 Deployment details 1.3 Daily Meeting Starter(Everyday at 11-12:30 pm) 1.3.1 Hathyar : Youtube video/twitter/github transcripts : fabric github repo, videos related to ai agents, twitter posts related to ai agents and fabric. 1.3.2 Chinthan : Real world translation : Migration of ai agents from local to hakuna matata 1.3.3 Prasar : Deployment details : I feel lot more confident next week starting phase 2 work. 1.4 Phase meeting middler(Every wednesday : 16Oct24) 1.4.1 1.5 Phase meeting ender(Every friday: 10Oct24) 1.5.1 User Documentation : Update the Readme.md with the new changes before the deployment. 1.5.2 Github release : Create a new release with the new changes and update the changelog. 1.5.3 Backend Cleaning : Close the issue and delete the branch. 1.5.4 Group Testing : Deploy on Friday and happy weekend. Better the deployment happier the weekend. 1.6 PRD meeting middler(15Oct24) 1.6.1 1.7 PRD meeting ender(31Oct24) 1.7.1 PRD Meeting Transcripts: PRD Documents Phase List Issue List Github Issues","title":"Daily Pramana Vachana : I will master the patterns for the following documents"},{"location":"prd/GitturQT/","text":"Product Requirements Document (PRD) for GitturQT Date: [Insert Date] Prepared by: [Your Name] Table of Contents Introduction Objectives and Goals Product Overview Target Audience Key Features and Functionality Technical Requirements User Experience and Interface Design Workflow and Processes Performance and Scalability Security and Compliance Deployment and Maintenance Risks and Mitigation Strategies Appendices 1. Introduction GitturQT is an innovative platform designed to streamline the developer workflow by automating the transition from ideas to deployment. By leveraging AI agents and integrating key development processes, GitturQT aims to become an indispensable tool for developers, reducing manual overhead and enhancing productivity. 2. Objectives and Goals Simplify Developer Workflow: Minimize the manual tasks developers face by automating processes from idea inception to deployment. End-to-End Integration: Provide a seamless experience where developers can input ideas, and the system handles PRD creation, task extraction, issue generation, coding, and deployment. User-Centric Design: Ensure that developers have control with review systems at each step, allowing for manual interventions when necessary. Leverage AI and Pattern Recognition: Utilize advanced AI agents and fabric patterns to interpret inputs and generate accurate outputs. 3. Product Overview GitturQT is a desktop application built with Python and PyQt. It serves as a unified platform where developers can: Input project ideas or requirements. Automatically generate detailed PRDs. Extract tasks and prioritize them. Convert tasks into GitHub issues with comprehensive descriptions. Automate coding and deployment processes. Interact with AI agents for assistance and guidance. 4. Target Audience Primary Users: Software developers seeking to optimize their workflow. Secondary Users: Project managers and team leads looking for tools to enhance team productivity. 5. Key Features and Functionality 5.1 Idea Input and PRD Generation(Phase 1) Start Date : 07-10-2024 End Date : 11-10-2024 Pramana Vachana : Conceptual understanding of the project by implementing issues portion. By the end of this phase I should be able to create issues from phase 1 document. Middle Out Audio Transcription: Record meetings and convert audio to text transcripts we will be using AssemblyAI to generate the text transcripts using our hakuna matata fastapi server. AI-Powered PRD Creation: Use AI agents created by us to generate detailed PRDs from transcripts and additional documents. Custom Prompts: Allow optional custom prompts to guide PRD generation. Fabric Pattern Recognition: Implement fabric library to recognise the patterns to identify key elements in inputs. PRD Review: Developers can review generated PRDs, provide feedback, and request changes. PRD Verification: Ensure PRDs meet project requirements and guidelines. 5.2 Task Management(Phase 2) Task Extraction: AI agents extract tasks from PRDs, categorize by priority or phase if not done by the AI agent it will be categorized by the developer in the QT app. Task Assignment: Assign tasks to developers with estimated time frames and priorities(Manual review to check the time frame and priority). Priority Setting: Set task priorities to manage workflow effectively(Manual review to check the priority). Manual Review: Developers can review tasks, provide feedback, and request changes. 5.3 GitHub Integration(Phase 3) Issue Generation: Convert selected tasks into GitHub issues with detailed descriptions, acceptance criteria, documentation links and details from the PRD. Automated Coding: Utilize AI agents to write code based on GitHub issues(Need to discuss this more in detail). Manual Review Developers can review code, provide feedback, and request changes. Deployment Automation: Once code is approved, commit the changes to the repository. 5.4 User Interface Intuitive Design: A clean, user-friendly interface built with PyQt. Customization Options: Allow users to customize settings and preferences. 6. Technical Requirements 6.1 Technology Stack Programming Language: Python GUI Framework: PyQt AI Libraries: Integration with AI models (e.g., OpenAI GPT models) Pattern Recognition: Fabric library and pattern modules Version Control Integration: GitHub API for issue management 6.2 System Architecture Modular Design: Separate components for AI agents, UI, task management, and GitHub integration. Scalability: Design architecture to accommodate future features and increased user load. 7. User Experience and Interface Design Dashboard View: Overview of projects, tasks, and progress. Step-by-Step Workflow: Guided process from idea input to deployment. Notifications: Alerts for review prompts, task completions, and deployment statuses. Accessibility: Ensure the application is accessible to users with varying needs. 8. Workflow and Processes 8.1 Initial Setup User installs GitturQT and links their GitHub account. Configure settings for AI agents and preferences. 8.2 Idea to PRD Meeting Recording: Record project meetings within the app or import audio files. Transcription: Automatic conversion of audio to text. PRD Generation: AI agent creates a PRD using the transcript, documents, and optional custom prompts. Review: User reviews the PRD and approves or requests changes. 8.3 Task Extraction and Management Task Extraction: AI agent extracts tasks from the approved PRD. Review and Edit: User reviews tasks, sets priorities, assigns developers, and sets deadlines. Task Confirmation: Finalize tasks for issue generation. 8.4 Issue Generation and Coding GitHub Issues: Selected tasks are converted into detailed GitHub issues. Code Generation: AI agents begin coding based on the issues. Review Code: Developers review, test, and approve code before merging. 8.5 Deployment Automated Deployment: Code is deployed using predefined pipelines. Monitoring: System monitors deployment for any issues. Feedback Loop: Post-deployment reviews to refine future processes. 9. Performance and Scalability Efficient Processing: Optimize AI agent performance for quick PRD and task generation. Load Handling: Ensure the app can handle multiple projects and users simultaneously. Resource Management: Efficient use of system resources to prevent bottlenecks. 10. Deployment and Maintenance Continuous Integration/Continuous Deployment (CI/CD): Set up pipelines for regular updates. Support and Updates: Provide regular updates and address user feedback promptly. Documentation: Maintain comprehensive documentation for users and developers. Conclusion GitturQT aims to revolutionize the developer workflow by automating routine tasks and allowing developers to focus on creativity and problem-solving. By integrating AI agents, providing a seamless user experience, and ensuring robust security, GitturQT will become an essential tool in the modern developer's toolkit. We look forward to collaborating with the engineering team to bring this vision to life, addressing any challenges, and creating a product that not only meets but exceeds user expectations.","title":"GitturQT"},{"location":"prd/GitturQT/#product-requirements-document-prd-for-gitturqt","text":"Date: [Insert Date] Prepared by: [Your Name]","title":"Product Requirements Document (PRD) for GitturQT"},{"location":"prd/GitturQT/#table-of-contents","text":"Introduction Objectives and Goals Product Overview Target Audience Key Features and Functionality Technical Requirements User Experience and Interface Design Workflow and Processes Performance and Scalability Security and Compliance Deployment and Maintenance Risks and Mitigation Strategies Appendices","title":"Table of Contents"},{"location":"prd/GitturQT/#1-introduction","text":"GitturQT is an innovative platform designed to streamline the developer workflow by automating the transition from ideas to deployment. By leveraging AI agents and integrating key development processes, GitturQT aims to become an indispensable tool for developers, reducing manual overhead and enhancing productivity.","title":"1. Introduction"},{"location":"prd/GitturQT/#2-objectives-and-goals","text":"Simplify Developer Workflow: Minimize the manual tasks developers face by automating processes from idea inception to deployment. End-to-End Integration: Provide a seamless experience where developers can input ideas, and the system handles PRD creation, task extraction, issue generation, coding, and deployment. User-Centric Design: Ensure that developers have control with review systems at each step, allowing for manual interventions when necessary. Leverage AI and Pattern Recognition: Utilize advanced AI agents and fabric patterns to interpret inputs and generate accurate outputs.","title":"2. Objectives and Goals"},{"location":"prd/GitturQT/#3-product-overview","text":"GitturQT is a desktop application built with Python and PyQt. It serves as a unified platform where developers can: Input project ideas or requirements. Automatically generate detailed PRDs. Extract tasks and prioritize them. Convert tasks into GitHub issues with comprehensive descriptions. Automate coding and deployment processes. Interact with AI agents for assistance and guidance.","title":"3. Product Overview"},{"location":"prd/GitturQT/#4-target-audience","text":"Primary Users: Software developers seeking to optimize their workflow. Secondary Users: Project managers and team leads looking for tools to enhance team productivity.","title":"4. Target Audience"},{"location":"prd/GitturQT/#5-key-features-and-functionality","text":"","title":"5. Key Features and Functionality"},{"location":"prd/GitturQT/#51-idea-input-and-prd-generationphase-1","text":"","title":"5.1 Idea Input and PRD Generation(Phase 1)"},{"location":"prd/GitturQT/#start-date-07-10-2024","text":"","title":"Start Date : 07-10-2024"},{"location":"prd/GitturQT/#end-date-11-10-2024","text":"","title":"End Date : 11-10-2024"},{"location":"prd/GitturQT/#pramana-vachana-conceptual-understanding-of-the-project-by-implementing-issues-portion-by-the-end-of-this-phase-i-should-be-able-to-create-issues-from-phase-1-document","text":"","title":"Pramana Vachana : Conceptual understanding of the project by implementing issues portion. By the end of this phase I should be able to create issues from phase 1 document."},{"location":"prd/GitturQT/#middle-out","text":"Audio Transcription: Record meetings and convert audio to text transcripts we will be using AssemblyAI to generate the text transcripts using our hakuna matata fastapi server. AI-Powered PRD Creation: Use AI agents created by us to generate detailed PRDs from transcripts and additional documents. Custom Prompts: Allow optional custom prompts to guide PRD generation. Fabric Pattern Recognition: Implement fabric library to recognise the patterns to identify key elements in inputs. PRD Review: Developers can review generated PRDs, provide feedback, and request changes. PRD Verification: Ensure PRDs meet project requirements and guidelines.","title":"Middle Out"},{"location":"prd/GitturQT/#52-task-managementphase-2","text":"Task Extraction: AI agents extract tasks from PRDs, categorize by priority or phase if not done by the AI agent it will be categorized by the developer in the QT app. Task Assignment: Assign tasks to developers with estimated time frames and priorities(Manual review to check the time frame and priority). Priority Setting: Set task priorities to manage workflow effectively(Manual review to check the priority). Manual Review: Developers can review tasks, provide feedback, and request changes.","title":"5.2 Task Management(Phase 2)"},{"location":"prd/GitturQT/#53-github-integrationphase-3","text":"Issue Generation: Convert selected tasks into GitHub issues with detailed descriptions, acceptance criteria, documentation links and details from the PRD. Automated Coding: Utilize AI agents to write code based on GitHub issues(Need to discuss this more in detail). Manual Review Developers can review code, provide feedback, and request changes. Deployment Automation: Once code is approved, commit the changes to the repository.","title":"5.3 GitHub Integration(Phase 3)"},{"location":"prd/GitturQT/#54-user-interface","text":"Intuitive Design: A clean, user-friendly interface built with PyQt. Customization Options: Allow users to customize settings and preferences.","title":"5.4 User Interface"},{"location":"prd/GitturQT/#6-technical-requirements","text":"","title":"6. Technical Requirements"},{"location":"prd/GitturQT/#61-technology-stack","text":"Programming Language: Python GUI Framework: PyQt AI Libraries: Integration with AI models (e.g., OpenAI GPT models) Pattern Recognition: Fabric library and pattern modules Version Control Integration: GitHub API for issue management","title":"6.1 Technology Stack"},{"location":"prd/GitturQT/#62-system-architecture","text":"Modular Design: Separate components for AI agents, UI, task management, and GitHub integration. Scalability: Design architecture to accommodate future features and increased user load.","title":"6.2 System Architecture"},{"location":"prd/GitturQT/#7-user-experience-and-interface-design","text":"Dashboard View: Overview of projects, tasks, and progress. Step-by-Step Workflow: Guided process from idea input to deployment. Notifications: Alerts for review prompts, task completions, and deployment statuses. Accessibility: Ensure the application is accessible to users with varying needs.","title":"7. User Experience and Interface Design"},{"location":"prd/GitturQT/#8-workflow-and-processes","text":"","title":"8. Workflow and Processes"},{"location":"prd/GitturQT/#81-initial-setup","text":"User installs GitturQT and links their GitHub account. Configure settings for AI agents and preferences.","title":"8.1 Initial Setup"},{"location":"prd/GitturQT/#82-idea-to-prd","text":"Meeting Recording: Record project meetings within the app or import audio files. Transcription: Automatic conversion of audio to text. PRD Generation: AI agent creates a PRD using the transcript, documents, and optional custom prompts. Review: User reviews the PRD and approves or requests changes.","title":"8.2 Idea to PRD"},{"location":"prd/GitturQT/#83-task-extraction-and-management","text":"Task Extraction: AI agent extracts tasks from the approved PRD. Review and Edit: User reviews tasks, sets priorities, assigns developers, and sets deadlines. Task Confirmation: Finalize tasks for issue generation.","title":"8.3 Task Extraction and Management"},{"location":"prd/GitturQT/#84-issue-generation-and-coding","text":"GitHub Issues: Selected tasks are converted into detailed GitHub issues. Code Generation: AI agents begin coding based on the issues. Review Code: Developers review, test, and approve code before merging.","title":"8.4 Issue Generation and Coding"},{"location":"prd/GitturQT/#85-deployment","text":"Automated Deployment: Code is deployed using predefined pipelines. Monitoring: System monitors deployment for any issues. Feedback Loop: Post-deployment reviews to refine future processes.","title":"8.5 Deployment"},{"location":"prd/GitturQT/#9-performance-and-scalability","text":"Efficient Processing: Optimize AI agent performance for quick PRD and task generation. Load Handling: Ensure the app can handle multiple projects and users simultaneously. Resource Management: Efficient use of system resources to prevent bottlenecks.","title":"9. Performance and Scalability"},{"location":"prd/GitturQT/#10-deployment-and-maintenance","text":"Continuous Integration/Continuous Deployment (CI/CD): Set up pipelines for regular updates. Support and Updates: Provide regular updates and address user feedback promptly. Documentation: Maintain comprehensive documentation for users and developers.","title":"10. Deployment and Maintenance"},{"location":"prd/GitturQT/#conclusion","text":"GitturQT aims to revolutionize the developer workflow by automating routine tasks and allowing developers to focus on creativity and problem-solving. By integrating AI agents, providing a seamless user experience, and ensuring robust security, GitturQT will become an essential tool in the modern developer's toolkit. We look forward to collaborating with the engineering team to bring this vision to life, addressing any challenges, and creating a product that not only meets but exceeds user expectations.","title":"Conclusion"}]}